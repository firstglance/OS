启动：
加电启动、正常运行，应用程序工作
提供接口：
为应用提供服务、控制外设与外设交互，涉及到：中断异常系统调用

加电后包括：CPU、内存、I/O

磁盘存放：Bootloader、OS
由Bios提供支持，进行检测外设，去加载软件
加电启动后，Bios从这个地址执行，自检
如：屏幕、键盘、鼠标等进行初始化检查，
接下来，把bootloader放到内存中去
bootloader（在硬盘的第一个扇区）
bootloader加载OS到内存

BIOS:
BIOS:将Booeloader从磁盘的引导扇区(512字节)加载到内存的0x7c00，
然后CPU的控制权就有Bootloader来掌控
Bootloader:
接下来Bootloader做的事情，加载OS
是找到硬盘中OS的起至扇区，以及OS长度，把磁盘块从磁盘读到内存完成后
把CPU控制权交给OS，即：跳到OS的起始地址去执行，OS就可以在内存中进行工作
前期初始化，后期创建程序运行，硬件管理处于OS下


操作系统与设备和程序交互

InterFace:
外设：中断和I/O
应用程序：系统调用和异常
三个：系统调用、异常、中断

系统调用：app向OS发出服务请求，希望操作系统提供支持，让OS完成相应功能(主动)
异常：应用程序执行过程中出现意外的情况(非主动，app执行中出现意外情况)
中断：来自外设，外设有事情需要OS去支持，通过中断机制让OS感知，让OS支持。

定义：
系统调用(来源于应用程序)
    app主动向操作系统发出服务请求
异常(来源于不良的应用程序)
    非法指令或者其他坏的处理状态(如：内存出错)
中断(来源于外设)
    来自不同的硬件设备的计时器和网络的中断

为什么通过系统调用外设？而不是通过应用程序调用外设？
OS是可以信任的软件、OS具有计算机控制权，可执行特权指令，为上层应用提供简单的接口，屏蔽的层复杂性，方便设计应用程序通用可移植
应用程序不安全，恶意程序可能破坏系统，不能直接访问外设，不然很可能造成计算机系统的崩溃

操作系统如何设计和实现中断、异常和系统调用
它们三者有什么区别和特点

源头
中断：来源于外设(键盘、鼠标等)
异常：应用程序意想不到的行为
系统调用：应用程序请求操作系统提供服务

处理事件
中断：异步
异常：同步
系统调用：异步或同步
          请求是同步，返回可能是同步或者异步
响应
中断：持续，对用户应用程序是透明的
异常：杀死或者重新执行意想不到的应用程序指令
系统调用：等待和持续

中断和异常的处理过程
含硬件和软件的处理过程

产生之后，应该判断有那个特定的服务例程去处理这个异常，
有张表：
一侧：key是中断号、异常号，对应地址，针对中断特定中断服务例程的地址
      不同外设，不同中断号，不同的服务例程
      假定收到中断，查中断表，然后查找中断服务例程地址
硬件：
    设置中断标记(如CPU初始化)
    1、将内部、外部事件设置中断标记，CPU根据中断标记找到中断号，根据中断号找到中断服务例程
    2、中断事件的ID
    
软件：
     保存当前处理状态(首先保存执行现场)，保存后，根据CPU提供的中断号，找到中断处理例程
     中断服务处理程序
     清楚中断标记
     恢复之前保存的处理状态

异常：异常编号
    保存现场
    异常处理
       杀死产生了异常的程序
       重新执行异常指令
    恢复现场

系统调用：
    
    程序访问序主要是通过高层次的API接口(通用的接口)而不是直接进行系统调用
    应用程序通过通用的接口，完成各种个样的功能，来对操作系统进行间接的控制和管理
    为方便应用程序使用操作系统提供的接口，有很多定义好的API如：
    Win32 API
    POSIX API
    Java API 这些API不是系统调用，而是Java虚拟机提供的支持，最终看跑的平台，由平台API提供系统调用
    
    通常情况下，与每个系统调用相关的序号
      系统调用接口根据这些序号来维护表的索引
    系统调用接口调用内核态中预期的系统调用
      并返回系统调用的状态和其他任何返回值
    用户不需要知道系统调用是如何实现的
      只需要获取API和了解操作系统将什么作为返回结果
      操作系统接口的细节大部分都隐藏在API中
        通过运行程序支持的库来管理(用包含编译器的库来创建函数集)

OS怎么设计和实现系统调用API

应用了解：
    系统调用提供什么样的功能，接口是什么？参数是怎么定义的

应用程序通过Library库访问API接口，会触发从用户态到内核态的转变
用户态：应用程序在执行过程中CPU所处于的一个执行的特权级的状态，特权级较低，不能直接访问I/O及不能访问某些特殊的及其指令；
内核态：操作系统过程中CPU所处于的一个状态，OS可以执行任何一条指令
